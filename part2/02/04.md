## 4. 공개SW R&D 과제 구현
### 가. 공개SW R&D 과제의 개발 방법론
공개SW 연구개발과제의 초기 단계는 외부 기여자와 협업이 없으므로 일반적인 소프트웨어 개발 방법론을적용하면서 진행할 수 있지만, 결과물을 공식적으로 공개한 이후에는 다음과 같은 방식으로 개발이 진행된다.<br>
<br>
공개SW 연구개발과제는 이처럼 외부 기여자의 이슈나 소스 코드 개선 요청을 상시 수용하면서 릴리즈를 관리해야 하므로, 점진적 개선이 가능한 XP, 스크럼, 칸반 등의 애자일 개발방법론을 적용하는 것이 좋다.

<p align="center"><img src="/assets/part2/02/04/image9.jpg" alt="그림 9. 공개SW 연구개발과제의 개발과정" title="그림 9. 공개SW 연구개발과제의 개발과정" width="750px"></p>

<br>

대부분의 공개SW 프로젝트는 조기 출시, 잦은 출시의 특징을 가지고 있으며 전통적인 소프트웨어 개발환경에 익숙해진 개발자들에게 가장 큰 차이점은 빠른 속도로 진행되는 개발과정이다. 공개SW 연구개발과제의 수행자는 소프트웨어 개발과정에서 다음과 같은 사항을 고려해야 한다.

- 처음부터 완벽한 코드를 제출하려고 하지 말고 목표를 달성하기에 충분할 때 제출한다.
- 가능한 최소의 합리적인 크기로 구현해서 작은 변경을 테스트 및 통합하도록 제출한다.
- 개발한 소스 코드를 다시 사용할 수 있도록 준비하자.<br>
<br>

만약 외부의 공개SW 프로젝트를 활용하여 과제에 사용한 경우에는 업스트림(가지고 온 원래 프로젝트)에 기여하는 절차를 개발과정에 포함하는 것이 필요하다. 그냥 발견한 공개SW를 다운로드 후 과제에 사용하기가 더 쉬워 보일
수 있지만, 다음과 같은 이유로 업스트림에 기여하는 것이 더 유리하다. <sup id="part2_2_04">[4](#footnote1)</sup>

- 변경사항을 업스트림 프로젝트에 통합하여 완제품을 제작하는 데 드는 노력의 양을 줄일 수 있다.
- 제출한 변경사항에 대해 업스트림 프로젝트에서 기여자의 자원 활용(리뷰 또는 개선)이 가능하다.
- 업스트림 프로젝트에 기여는 향후 프로젝트 방향에 영향을 줄 기회를 제공한다.
- 자신의 코드가 우발적으로 파손될 위험이 줄어든다.

<p align="center"><img src="/assets/part2/02/04/image10.jpg" alt="그림 10. 공개SW 프로젝트의 업스트림 개발 과정" title="그림 10. 공개SW 프로젝트의 업스트림 개발 과정" width="970px"></p><br>

### 나. 공개SW R&D 과제의 소프트웨어 형상 관리
공개SW 연구개발과제의 수행자는 소프트웨어 소스 코드의 형상을 관리하기 위한 도구를 준비하고 어떤 브랜치 전략으로 과제를 수행할지, 커밋 메시지를 작성하는 표준은 어떻게 할지 등을 결정하고 참여하는 모든 연구원이 이 절차를 준수하도록 관리해야 한다.<br>
<br>
최근의 대부분 공개SW 프로젝트는 형상 관리 도구로 git을 사용하며 소스 코드 저장소는 github을 사용하며 gitlab이나 bitbucket을 사용하여 과제를 위한 환경을 직접 내부에 구축하여 운영하기도 한다.

- 브랜치 모델

    형상 관리 도구를 준비한 이후에는 다수의 개발자가 하나의 소스 코드 저장소를 사용할 때 저장소를 효율적으로 관리하기 위한 워크플로우가 필요하며, git-flow, github-flow, branch-per-issue 등의 조직의 규모, 서비스의 특징, 프로젝트에 참여하고 있는 구성원들이 제각기 달라서 자신의 상황에 맞는 다양한 브랜치 모델을 사용해야 한다.

    git-flow는 5가지의 브랜치를 이용해서 저장소를 운영하는 브랜치 모델이다. 5가지 중 항시 유지되는 메인 브랜치(master, develop) 2가지와 소스 코드가 병합되면 사라지는 보조 브랜치(feature, release, hotfix) 3가지로 구성된다.


<p align="center"><img src="/assets/part2/02/04/image11.jpg" alt="그림 11. git-flow" title="그림 11. git-flow" width="650px"></p><br>

- master : 라이브 서버에 제품으로 출시되는 브랜치.
- develop : 다음 출시 버전을 대비하여 개발하는 브랜치.
- feature : 기능 개발 브랜치. develop 브랜치에 들어간다.
- release : 다음 버전 출시를 준비하는 브랜치. develop 브랜치를 release 브랜치로 옮긴 후 QA, 테스트를 진행하고 master 브랜치로 합친다.
- hotfix : master 브랜치에서 발생한 버그를 수정하는 브랜치.

주기적으로 배포, QA 및 테스트, hotfix 등 수행할 수 있는 여력이 있는 팀이라면 git-flow로 각각의 브랜치를 체계적으로 관리할 수도 있지만, 릴리즈 주기가 짧고 서비스를 지속적으로 테스트하고 배포하는 조직의 경우는 git-flow보다 간단한 github-flow 모델을 사용할 수 있다.<br>
<br>
github-flow는 git-flow가 Github에서 사용하기에는 복잡하다고 나온 브랜치 모델이다. 이 브랜치 모델은 메인 브랜치(일반적으로 master 또는 main 브랜치를 의미)에 대한 역할만 잘 관리하는 방식으로 hotfix 브랜치나 feature 브랜치를 구분하지 않고, 새로운 기능 추가 또는 이슈 해결이 필요한 시점에 작업 브랜치를 생성하여 관리하고 작업이 끝난 소스 코드의 병합은 깃허브에서 제공하는 pull request 기능을 사용하도록 권장하는 방식이다.<sup id="part2_2_04">[5](#footnote1)</sup>

<p align="center"><img src="/assets/part2/02/04/image12.jpg" alt="그림 12. github-flow" title="그림 12. github-flow" width="500px"></p><br>

### :mortar_board: github-flow 사용법
1. **main 브랜치는 어느 시점이든 소프트웨어의 배포가 가능해야 한다.**
    -  먼저 과제 수행 컨소시엄 구성원들에게 분산되어 보관되는 소스 코드가 있는 경우, 모든 소스 코드를 main 브랜치에서 관리하도록 구성한다.
    - main 브랜치는 항상 최신 상태며, 안정적인 상태로 유지되어야 하며 소프트웨어 배포에 사용되는 브랜치. 따라서 이 브랜치에 대해서는 소스 코드를 병합하기 전에 충분한 테스트가 필요하며 엄격한 규칙으로 관리되어야 한다.
    - 테스트는 브랜치를 최신으로 병합하고 릴리즈 관리 도구(Jenkins, Travis CI 등)를 통해 테스트할 수 있도록
구성한다.
2. **기능 추가나 이슈 해결을 위해 소스 코드의 수정을 할 때 브랜치의 생성은 항상 main 브랜치에서 만들고, main 브랜치에서 새로운 일을 시작하기 위해 브랜치를 만들 때는 브랜치의 이름을 명확히 작성한다.**
    - 새로운 기능을 추가하거나, 버그를 해결하기 위한 브랜치 이름은 자세하게 어떤 일을 하고 있는지에 대해서
작성한다.
    - 커밋 메시지는 여러 사람과 같이 개발할 때 서로 간의 코드 리뷰에 도움이 되므로 표준을 정의하고 준수한다.
3. **개발자는 작업 중인 원격 저장소 브랜치로 자주 병합해야 한다.**
    - 항상 원격 저장소에 자신이 하는 작업을 반영하여 다른 사람들도 확인할 수 있도록 해야 한다.
    - 개발환경에 문제가 발생해 작업하던 부분이 없어지더라도, 원격 저장소에 있는 소스를 받아서 작업할 수
있도록 관리해야 한다.
4. **피드백이나 도움이 필요할 때, 그리고 병합할 준비가 완료되었을 때는 풀리퀘스트(pull request)를 생성한다.**
    - 풀리퀘스트(pull request)는 소프트웨어의 형상 관리를 책임지는 책임자에게 소스 코드의 병합을 위해 리뷰를 요청하는 행동이다.
    - 풀리퀘스트(pull request)를 이용해 자신의 코드를 공유하고 리뷰를 요청한 후 리뷰어의 검토 사항에 따라 발견한 리뷰 내용을 수정한다.
    - 리뷰어의 검토사항을 모두 수정하고 병합을 할 준비가 완료되었다면 main 브랜치로 반영을 요구하도록 한다.
5. **소스 코드의 기능에 대한 리뷰가 끝난 후 main 브랜치로 병합한다.**
    - 병합을 반영하면 바로 릴리즈로 반영이 될 기능이므로, 이해관계자들과 충분한 논의 이후 반영하도록 한다.
    - main 브랜치에 병합이 완료되면 작업한 브랜치는 삭제한다.
6. **소스 코드가 main 브랜치로 병합되어 적용되면 소프트웨어의 새 릴리즈가 즉시 배포된다.**
    - 이 부분이 GitHub-flow의 핵심으로 워크플로우 자동화도구인 깃헙액션 또는 자신이 사용중인 릴리즈 관리 도구의 트리거를 이용하여 main 브랜치의 변경이 일어나면 자동으로 배포가 되도록 설정해 놓는다
    - 병합한 이후에는 릴리즈 자동화 도구의 결과를 확인하여 오류가 없는지 점검한다. 
<br>

- 커밋 메시지 작성하기

    공개된 프로젝트에 참여하고 싶은 외부 기여자는 커밋 메시지를 통해 공개된 소프트웨어의 변경 이력을 분석할 때 도움이 되기 때문에 누구나 쉽게 이해할 수 있도록 작성하는 것이 필요하다.<br>
<br>
공개SW 연구개발 과제의 수행자는 소프트웨어 소스 코드 저장소에 새로운 소스 코드가 반영될 때 입력하는 커밋 메시지의 표준을 정의하고 참여연구원 전원이 준수할 수 있도록 관리하여 소프트웨어 소스 코드의 무의미한 커밋을 방지하고 외부 기여자의 쉬운 프로젝트 참여 환경을 구축할 수 있다.<br>
<br>

별도의 커밋 메시지 표준이 없는 경우에는 다음과 같은 커밋 메시지 규칙(Udacity Git Commit Message Style
Guide)을 참고할 수 있다. <sup id="part2_2_06">[6](#footnote3)</sup>

- 커밋 메시지는 크게 제목, 본문, 꼬리말 세 가지 부분으로 나누고, 각 부분은 빈 줄을 두어 구분하여 작성하자. 
- type : 어떤 의도로 커밋을 했는지 알 수 있도록 type에 명시.
- subject : 최대 50글자가 넘지 않도록 하고 마침표는 찍지 않는다. 영문으로 표기하는 경우 동사(원형)를 가장 앞에 두고 첫 글자는 대문자로 표기.
- body : 긴 설명이 필요한 경우에 작성. 어떻게 했는지가 아니라, 무엇을 왜 했는지를 최대 75자를 이내로 작성.
- footer : issue tracker ID를 명시하고 싶은 경우에 작성.

<br>

<p align="center"><img src="/assets/part2/02/04/image13.jpg" alt="그림 13. 커밋 메시지 구조" title="그림 13. 커밋 메시지 구조" width="480px"></p>

<br>

이런 규칙을 적용하여 커밋 메시지를 작성하면 다음과 같이 작성할 수 있다.<br>

<p align="center"><img src="/assets/part2/02/04/image14.jpg" alt="그림 14. 커밋 메시지 작성 예" title="그림 14. 커밋 메시지 작성 예" width="740px"></p>

<br>

### :notebook: 클라우드바리스타 커뮤니티 사례
- 신규 컨트리뷰터를 위해 “GitHub를 통한 Cloud-Barista 컨트리뷰션 절차 가이드” 제공: https://github.com/cloud-barista/docs/blob/master/contributing/how_to_open_a_pull_request-ko.md
- 클라우드바리스타 커뮤니티의 공개SW 기여 방법


<p align="center"><img src="/assets/part2/02/04/cb_img_3.jpg" alt="[클라우드바리스타 커뮤니티 협업/기여 방법 절차]" title="[클라우드바리스타 커뮤니티 협업/기여 방법 절차]" width="970px"></p>

1. Propose an issue: 이슈 오픈/생성/제안하는 작업
2. Discuss the issue: 이슈와 관련된 사람들간 논의 작업
3. Assign/self-assign the issue to contributors: 논의를 바탕으로 이슈 담당자 자원/배정 작업
4. Fork/Sync (Fetch and merge) upstream: 처음이면 업스트림을 포크 / 처음이 아니면 업스트림의 최신 변경사항을 동기화
5. Create branch: 이슈 해결을 위한 브랜치 생성 작업 (로컬 저장소에서 수행해도 무방)
6. Fetch/pull:
    - Fetch는 원격 저장소의 내용을 가져오는 작업
    - Pull은 원격 저장소의 내용을 가져와 자동으로 병합 작업까지 수행
7. Checkout: 작업을 위한 브랜치로 변경
8. Improve/develop: 이슈 해결/개선 작업
9. Build test: 이슈 해결/개선 사항의 빌드 성공 여부 테스트 수행
10. Commit: 이슈 해결/개선 사항을 기록
11. Fetch upstream (e.g., upstream/main): 업스트림의 최신 변경사항을 가져옴
12. Rebase (if needed): 업스트림에 변경된 내용이 있다면 작업 브랜치의 Base를 최신 업스트림으로 변경하는 작업
13. Push: 로컬 저장소의 변경 이력을 원격 저장소에 공유/업로드하는 작업
14. Perform tests in the guided test environment (An issue occurs, do step 8-14): 기여자/개발자/사용자에게 안내된 테스트 환경 및 방법이 있다면 이에 대한 테스트 수행 (테스트 수행 중, 이슈 발생 시 8-14 수행)
15. Pull request (PR): 작업한 브랜치의 내용(이슈 해결/개선 사항)을 upstream에 반영해 달라고 요청하는 작업 및 다른 기여자에게 변경사항이 있음을 알리는 작업
16. Review and make comments: 이슈 해결/개선사항 반영 요청에 대한 검토 수행 및 검토의견을 바탕으로 상호 논의 수행
17. Handle comments (do step 8-14, and squash/amend if needed): 검토의견 및 논의 내용을 반영 또는 개선 작업 수행 (필요에 따라 Squash/amend 수반)
18. Approve: 앞선 과정을 통해 이슈가 해결되었음을 승인하는 작업
19. Merge: 승인된 이슈 해결/개선 사항을 main 브랜치에 병합하는 작업<br>

> 클라우드바리스타의 커밋(Commit)을 참고로 추가하며, 추가로 How to Write a Git Commit Message(Chris
Beams) 내용을 번역, 편집하고 도움이 될만한 내용을 추가한 블로그((https://meetup.toast.com/posts/106)
를 참고하면 좋습니다.<br>

<br>

### :notebook: CB-Spider 프레임워크 사례
- #### **사례1)** 제목만으로 충분한 설명이 된 Commit 메시지
    https://github.com/cloud-barista/cb-spider/commit/0f6adc89ba0ead2929cc346088caf99b725ad233

<p align="center"><img src="/assets/part2/02/04/cb_img_4.jpg" alt="사례1) 제목만으로 충분한 설명이 된 Commit 메시지" title="사례1) 제목만으로 충분한 설명이 된 Commit 메시지"></p><br>

- #### **사례2)** 제목이 몇 가지 내용을 포괄하고 있어 상세 설명을 작성한 Commit 메시지

<p align="center"><img src="/assets/part2/02/04/cb_img_5.jpg" alt="사례2) 제목이 몇 가지 내용을 포괄하고 있어 상세 설명을 작성한 Commit 메시지" title="사례2) 제목이 몇 가지 내용을 포괄하고 있어 상세 설명을 작성한 Commit 메시지"></p><br>


### :notebook: CB-Tumblebug 프레임워크 사례
https://github.com/cloud-barista/cb-tumblebug/commit/4493e962ed19a52eba0ea1ac2968b448ff317ea4

<p align="center"><img src="/assets/part2/02/04/cb_img_6.jpg" alt="CB-Tumblebug 프레임워크 사례" title=" CB-Tumblebug 프레임워크 사례"></p><br>

### 다. 공개SW R&D 과제의 이슈 관리
공개SW 연구개발과제의 이슈 관리는 일반적인 소프트웨어 개발의 이슈 관리와 같이 다양한 이슈 관리 도구 (Bugzilla, redmine, Jira, github, Gitlab 등)를 이용해서 진행된다. 일반적인 소프트웨어 개발과 차이점은 이슈를 등록하는 역할이 내부 개발팀의 연구원이 아니라 공개된 프로젝트를 사용하는 외부 사용자일 수 있으므로 이슈 관리를 통해 연구개발과제의 진행 과정이 투명하게 남는다는 점이다.<br>
<br>
공개SW 연구개발과제의 수행자는 등록되는 이슈에 대하여 다음과 같은 절차를 준비하고 각 절차의 담당자를 배정하여 수행해야 한다.<br>

- 이슈 등록 : 사용자 혹은 품질관리팀이 발견한 버그 혹은 신규 기능을 추가한다. 담당자가 명확한 경우 지정하기도
하나 공란으로 남겨두는 일도 흔하다.
- 이슈 검토/분류 : 등록된 이슈는 개발팀이 검토한다. 중복, 재현 불가, 해결 불가능한 이슈의 경우 이 단계에서
이슈를 닫는다. 개발팀에서 해결할 이슈의 경우 담당자, 우선순위, 마감일 등을 지정한다.
- 이슈 해결 : 이슈가 해결되면 이슈를 닫는다. 담당자와 별개로 검증 담당자(Verifier)를 따로 두어 진짜로 이슈가
해결되었는지 검증하는 때도 있다.

이슈 관리 시스템은 사전에 정의된 이슈 템플릿을 생성하는 기능, 이슈의 유형을 식별하는 레이블 자동생성, 이슈의 담당자 지정 등 다양한 기능을 제공하고 있으므로 공개SW 연구개발과제의 수행자는 참여연구원 전체가 사용하는 이슈 관리 도구의 사용법을 미리 숙지할 수 있도록 교육하고 효율적으로 운영하는 것이 필요하다.<br>

<p align="center"><img src="/assets/part2/02/04/image15.jpg" alt="그림 15. 이슈 템플릿 기능의 예" title="그림 15. 이슈 템플릿 기능의 예" width="800px"></p><br>

### :notebook: 클라우드바리스타 커뮤니티 사례
- 클라우드바리스타 커뮤니티에서는 자료 조사 후 몇 차례 검토 회의를 통해 이슈 템플릿을 적용하였고, 아래는 CB-Tumeblebug의 이슈 템플릿에 대한 사례를 나타낸다.

<p align="center"><img src="/assets/part2/02/04/cb_img_7.jpg" alt="[이슈 템플릿 마크다운 경로 및 파일]" title="[이슈 템플릿 마크다운 경로 및 파일]" width="800px"></p><br>

<p align="center"><img src="/assets/part2/02/04/cb_img_8.jpg" alt="[이슈 템플릿 마크다운 내용]" title="[이슈 템플릿 마크다운 내용]" width="800px"></p><br>

<p align="center"><img src="/assets/part2/02/04/cb_img_9.jpg" alt="[이슈 생성 화면]" title="[이슈 생성 화면]" width="800px"></p><br>

<p align="center"><img src="/assets/part2/02/04/cb_img_10.jpg" alt="[이슈 생성 화면]" title="[이슈 생성 화면]" width="800px"></p><br>

### 라. 공개SW R&D 과제의 릴리즈 관리
공개SW 연구개발과제의 결과물을 배포하기 위해서는 개발된 프로그램 소스 코드와 배포용 바이너리 파일을 함께 포함하여 배포하는 것이 일반적인 배포방법이다. 깃허브의 경우 소스 코드와 빌드된 바이너리 파일을 함께 포함하여 온라인에서 쉽게 릴리즈 할 수 있는 도구를 제공하고 있으며 다음과 같이 사용할 수 있다.<br>
<br>

### 깃허브에서 소프트웨어 릴리즈 하는 법  
1. 릴리즈를 위해 저장소의 Releases 페이지 이동한다.
<p align="center"><img src="/assets/part2/02/04/git_img_1.jpg" width="800px"></p><br>

2. 페이지에서 Create a new release 버튼 선택
릴리즈된 버전이 없는 경우 아래와 같이 출력되며, Create a new release를 누르면 릴리즈할 항목을 선택할
수 있다.
<p align="center"><img src="/assets/part2/02/04/git_img_2.jpg" width="800px"></p><br>

3. 릴리즈 항목 입력
다음 그림과 같은 화면에서 릴리즈에 필요한 태그, 릴리즈 버전명, 릴리즈 내용, 추가할 바이너리 또는 기타 파일을 함께 업로드한다.
<p align="center"><img src="/assets/part2/02/04/git_img_3.jpg" width="800px"></p><br>

입력을 모두 마친 후, Publish release 버튼을 눌러보자!<br>

4. 패키지 배포 결과

<p align="center"><img src="/assets/part2/02/04/git_img_4.jpg" width="800px"></p><br>

직접 추가한 바이너리 파일들과 릴리즈 시점의 소프트웨어 소스 코드가 자동으로 첨부되어 릴리즈 페이지에
제공된다.<br>
<br>
이때 소프트웨어 릴리즈에 사용하는 버전 태그는 버전 이름 앞에 문자 v를 붙이는 것이 일반적이다. 태그가 프로덕션용으로 사용되지 않는 경우 버전 이름 뒤에 v0.2.0-alpha 또는 v5.9-beta처럼 이 릴리스 전 버전을 추가하는 방식으로 작성한다. 공개SW 연구개발과제의 수행자는 소프트웨어 출시 전 버전 번호를 어떻게 정할지 규칙을 결정하기 위해 사전에 다음과 같은 규칙을 정의하는 것이 필요하다.<br>
<br>

### Semantic Versioning 2.0.0
버전을 주.부.수 숫자로 하고 :

기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”을 올리고,<br>
기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”을 올리고,<br>
기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”을 올린다.<br>
주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.<sup id="part2_2_07">[7](#footnote4)</sup>

<br>

소프트웨어의 배포가 자주 이루어지지 않는 경우는 이처럼 수동으로 릴리즈 하는 핀포인트 릴리즈 방식을 사용해도 되지만, github-flow 같은 브랜치 모델을 사용하는 경우에는 항상 릴리즈를 최신으로 유지하는 것이 필요하며 Travis, Jenkins 등의 릴리즈 관리 도구의 기능을 이용하여 자동으로 소프트웨어가 배포되도록 지속적 통합 (Continuous Integration) 환경을 구성하는 DevOPS 방식을 구성하는 것이 좋다. <sup id="part2_2_08">[8](#footnote5)</sup>
<br>

지속적 통합(Continuous Integration) 환경이란 소프트웨어의 배포를 특정 시점에 계획하여 배포하는 핀포인트 릴리즈 방식이 아니라 작은 코드 변경이 이루어지는 시점에서 병합하여 배포를 수행하는 방식이다. 지속적 통합 (Continuous Integration) 환경은 소프트웨어 배포 전 통합테스트를 통해 검증하는 기존의 개발방식이 아니라 개발자의 프로그램 소스 코드 변경내용이 저장소에 반영되는 시점에 빌드, 테스트, 배포를 자동으로 수행하도록 구성하여 개발 종료 시 변화가 많은 상태로 병합하는 것보다 더 작은 규모로 개발하고 자주 테스트함으로써 건강한 소프트웨어를 만드는 방식으로, 성숙도가 높은 대부분의 공개SW 프로젝트는 지속적 통합 환경을 구축하여 프로젝트를 관리하고 있다.
<br>

<p align="center"><img src="/assets/part2/02/04/image16.jpg" width="800px" alt="[그림 16. 지속적 통합(Continuous Integration) 워크플로우]" title="[그림 16. 지속적 통합(Continuous Integration) 워크플로우]"></p><br>

좋은 지속적 통합 프로세스의 필수 요소<sup id="part2_2_09">[9](#footnote6)</sup>는 다음과 같다.

- 소스 코드 관리 시스템 사용 – 소스 코드 관리 시스템을 사용하지 않거나 소스 코드의 일부만 저장소에 있는 경우 첫 단계는 모든 소스 코드를 저장소에 가져오고 모든 팀원이 사용하도록 요청해야 한다.
- 자주 커밋하기 – 소스 관리 시스템을 사용하는 경우 참여연구원 모두가 자주 커밋하는 습관을 기르는 것이 중요하다. 커밋 시에는 작업 크기가 지나치게 크면 변경을 파악하기 어려우므로 각각의 작업을 더 작은 부분으로 나누어 쉽게 로컬에서 변경을 완료하고 테스트할 수 있도록 작업하고 자주 커밋해야 한다.
- 모든 커밋 이벤트 발생 시 빌드 – 프로젝트의 모든 구성원과 코드의 변경사항을 정기적으로 공유하도록 구성 후 최신 변경사항이 생기면 결과물의 빌드가 가능한지 확인할 수 있도록 구성한다. 이 작업을 수동으로 수행할 수 있지만 빌드를 자동으로 수행하도록 구성하면 훨씬 쉽고 효율적이며 이를 위하여 지속적 통합(Continuous Integration) 환경이 필요하다.
- 테스트 자동화 – 성공적인 빌드 결과는 좋은 신호이지만 소프트웨어의 품질을 더욱 확실히 관리하려면 테스트를 자동으로 실행하도록 구성하는 것이 좋다. 수동으로 테스트하기보다는 자동 테스트를 구성하면 보다 효율적이다.
- 피드백 경청 – 지속적 통합 환경에서 피드백 받은 정보를 기반으로 소프트웨어의 개선을 잘 수행하는 것이 중요하다. 이런 피드백의 편의성을 위해서 대부분의 지속적 통합(Continuous Integration) 도구들은 빌드가 실패하는 경우 이메일, 메신저 등의 알림을 연동하여 즉각적인 대응이 가능하도록 제공하고 있다.
- DevOps 문화 구축 – 지속적인 통합의 이점을 적절히 활용하려면 모든 팀원이 작동하지 않는 빌드를 수정하거나 테스트 실패에 책임감을 느끼는 팀 문화를 조성해야 한다. 마지막으로 커밋한 팀원만을 탓하기보다는 변경사항을 조기에, 자주 커밋하는 편이 프로젝트 수행팀 모두의 이익에 부합된다는 것을 이해하는 문화가 필요하다.

과제 수행자는 이런 지속적 통합 환경을 구축하기 위해서 Jenkins, Travis, Bamboo, TeamCity 등의 소프트웨어나 클라우드 서비스를 이용할 수 있으며, 깃허브에서는 Travis CI 서비스와 깃허브 소스 코드 저장소의 쉬운 연동을 지원하고 있으므로 다음과 같은 지속적 통합 배포 환경을 쉽게 구성할 수 있다. 이런 환경은 소프트웨어 품질 관리 프로세스를 상시 수행하고 있는 신뢰할 수 있는 프로젝트임을 의미하며 향후 외부 기여자들이 소스 코드의 개선에 적극적으로 참여할 수 있는 중요한 요소이다.

<p align="center"><img src="/assets/part2/02/04/image17.jpg" width="970px" alt="[그림 17. Travix CI 서비스를 이용한 지속적 통합 배포 환경의 구성 예]" title="[그림 17. Travix CI 서비스를 이용한 지속적 통합 배포 환경의 구성 예]"></p><br>

또 다른 방법으로 깃허브의 경우 소스 코드 저장소의 변경을 감지하여 필요한 조치를 추가로 수행하는 Github Action<sup id="part2_2_10">[10](#footnote7)</sup>이라는 워크플로우 자동화 기능을 제공하고 있으며, 이를 이용하면 메인테이너의 리뷰가 끝난 소스 코드를 저장소에 커밋하는 동시에 최신의 소프트웨어를 릴리즈하는 과정을 자동으로 수행되도록 다음과 같이 구성할 수도 있다.

<p align="center"><img src="/assets/part2/02/04/image17.jpg" width="970px" alt="[그림 18. Github Action을 이용한 지속적 통합 배포 환경의 구성 예]" title="[그림 18. Github Action을 이용한 지속적 통합 배포 환경의 구성 예]"></p><br>


### :notebook: 클라우드바리스타 커뮤니티 사례
- 클라우드바리스타 커뮤니티는 2019년도 v0.1.0-americano 첫 공개(Release)를 시작으로 매년 공개 행사를 통해 개발 소스 코드 및 산출 문서를 공개하고 있다. 

<p align="center"><img src="/assets/part2/02/04/cb_img_11.jpg" width="970px" alt="[클라우드바리스타 커뮤니티 오픈 세미나 및 릴리스 마일스톤]" title="[클라우드바리스타 커뮤니티 오픈 세미나 및 릴리스 마일스톤]"></p><br>

- 클라우드바리스타 커뮤니티 컨퍼런스를 통한 주요기술 현황 공유 소스코드 릴리스 계획 예시<br>
    https://github.com/cloud-barista/docs/wiki/Cloud-Barista-v0.5.0-(Affogato)-release-plan<br><br>
- 향후 개발 및 기여되는 수많은 신규 소스코트 통합으로 인해 발생하게 될 업무 부하(소위: Integration hell)에 대비하기 위하여 CI/CD 자동화를 도입하였으며, 도입된 CI 자동화 범위는 아래와 같다.

<p align="center"><img src="/assets/part2/02/04/cb_img_12.jpg" width="970px" alt="[클라우드바리스타 커뮤니티의 CI/CD 자동화 도입 범위]" title="[클라우드바리스타 커뮤니티의 CI/CD 자동화 도입 범위]"></p><br>

- GitHub에서 제공하는 워크플로 자동화 도구인 GitHub Actions를 활용하여 클라우드바리스타 CI/CD 자동화 파이프라인을 구현하였으며 아래 그림은 CI 워크플로 중 Build test 적용 사례를 나타낸다.

<p align="center"><img src="/assets/part2/02/04/cb_img_13.jpg" width="970px" alt="[클라우드바리스타 CI 워크플로 중 Build test 사례]" title="[클라우드바리스타 CI 워크플로 중 Build test 사례]"></p><br>

<br>

---

<b id="footnote1">4</b>) https://github.com/todogroup/ospo101 <sup>[return](#part2_2_04)</sup><br>
<b id="footnote2">5</b>) https://hellowoori.tistory.com/56 <sup>[return](#part2_2_05)</sup><br>
<b id="footnote3">6</b>) https://udacity.github.io/git-styleguide/ <sup>[return](#part2_2_06)</sup><br>
<b id="footnote4">7</b>) https://semver.org/lang/ko/ <sup>[return](#part2_2_07)</sup><br>
<b id="footnote5">8</b>) https://nimbella.com/blog/ci/cd-pipeline-with-github-actions <sup>[return](#part2_2_08)</sup><br>
<b id="footnote6">9</b>) https://www.jetbrains.com/ko-kr/teamcity/ci-cd-guide/continuous-integration-vs-delivery-vs-deployment/ <sup>[return](#part2_2_09)</sup><br>
<b id="footnote7">10</b>) https://docs.github.com/en/actions/quickstart <sup>[return](#part2_2_10)</sup><br>


