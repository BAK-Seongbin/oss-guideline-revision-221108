## 4. 공개SW R&D 과제 구현
### 가. 공개SW R&D 과제의 개발 방법론
공개SW 연구개발과제의 초기 단계는 외부 기여자와 협업이 없으므로 일반적인 소프트웨어 개발 방법론을적용하면서 진행할 수 있지만, 결과물을 공식적으로 공개한 이후에는 다음과 같은 방식으로 개발이 진행된다.<br>
<br>
공개SW 연구개발과제는 이처럼 외부 기여자의 이슈나 소스 코드 개선 요청을 상시 수용하면서 릴리즈를 관리해야 하므로, 점진적 개선이 가능한 XP, 스크럼, 칸반 등의 애자일 개발방법론을 적용하는 것이 좋다.

<p align="center"><img src="/assets/part2/image9.png" alt="그림 9. 공개SW 연구개발과제의 개발과정" title="그림 9. 공개SW 연구개발과제의 개발과정"></p>

<br>

대부분의 공개SW 프로젝트는 조기 출시, 잦은 출시의 특징을 가지고 있으며 전통적인 소프트웨어 개발환경에 익숙해진 개발자들에게 가장 큰 차이점은 빠른 속도로 진행되는 개발과정이다. 공개SW 연구개발과제의 수행자는 소프트웨어 개발과정에서 다음과 같은 사항을 고려해야 한다.

- 처음부터 완벽한 코드를 제출하려고 하지 말고 목표를 달성하기에 충분할 때 제출한다.
- 가능한 최소의 합리적인 크기로 구현해서 작은 변경을 테스트 및 통합하도록 제출한다.
- 개발한 소스 코드를 다시 사용할 수 있도록 준비하자.<br>
<br>

만약 외부의 공개SW 프로젝트를 활용하여 과제에 사용한 경우에는 업스트림(가지고 온 원래 프로젝트)에 기여하는 절차를 개발과정에 포함하는 것이 필요하다. 그냥 발견한 공개SW를 다운로드 후 과제에 사용하기가 더 쉬워 보일
수 있지만, 다음과 같은 이유로 업스트림에 기여하는 것이 더 유리하다. <sup id="part2_2_04">[4](#footnote1)</sup>

- 변경사항을 업스트림 프로젝트에 통합하여 완제품을 제작하는 데 드는 노력의 양을 줄일 수 있다.
- 제출한 변경사항에 대해 업스트림 프로젝트에서 기여자의 자원 활용(리뷰 또는 개선)이 가능하다.
- 업스트림 프로젝트에 기여는 향후 프로젝트 방향에 영향을 줄 기회를 제공한다.
- 자신의 코드가 우발적으로 파손될 위험이 줄어든다.

<p align="center"><img src="/assets/part2/image10.png" alt="그림 10. 공개SW 프로젝트의 업스트림 개발 과정" title="그림 10. 공개SW 프로젝트의 업스트림 개발 과정"></p>

<br>

### 나. 공개SW R&D 과제의 소프트웨어 형상 관리
공개SW 연구개발과제의 수행자는 소프트웨어 소스 코드의 형상을 관리하기 위한 도구를 준비하고 어떤 브랜치 전략으로 과제를 수행할지, 커밋 메시지를 작성하는 표준은 어떻게 할지 등을 결정하고 참여하는 모든 연구원이 이 절차를 준수하도록 관리해야 한다.<br>
<br>
최근의 대부분 공개SW 프로젝트는 형상 관리 도구로 git을 사용하며 소스 코드 저장소는 github을 사용하며 gitlab이나 bitbucket을 사용하여 과제를 위한 환경을 직접 내부에 구축하여 운영하기도 한다.

- 브랜치 모델

    형상 관리 도구를 준비한 이후에는 다수의 개발자가 하나의 소스 코드 저장소를 사용할 때 저장소를 효율적으로 관리하기 위한 워크플로우가 필요하며, git-flow, github-flow, branch-per-issue 등의 조직의 규모, 서비스의 특징, 프로젝트에 참여하고 있는 구성원들이 제각기 달라서 자신의 상황에 맞는 다양한 브랜치 모델을 사용해야 한다.

    git-flow는 5가지의 브랜치를 이용해서 저장소를 운영하는 브랜치 모델이다. 5가지 중 항시 유지되는 메인 브랜치(master, develop) 2가지와 소스 코드가 병합되면 사라지는 보조 브랜치(feature, release, hotfix) 3가지로 구성된다.

<br>

<p align="center"><img src="/assets/part2/image11.png" alt="그림 11. git-flow" title="그림 11. git-flow"></p>

<br>

- master : 라이브 서버에 제품으로 출시되는 브랜치.
- develop : 다음 출시 버전을 대비하여 개발하는 브랜치.
- feature : 기능 개발 브랜치. develop 브랜치에 들어간다.
- release : 다음 버전 출시를 준비하는 브랜치. develop 브랜치를 release 브랜치로 옮긴 후 QA, 테스트를 진행하고 master 브랜치로 합친다.
- hotfix : master 브랜치에서 발생한 버그를 수정하는 브랜치.

주기적으로 배포, QA 및 테스트, hotfix 등 수행할 수 있는 여력이 있는 팀이라면 git-flow로 각각의 브랜치를 체계적으로 관리할 수도 있지만, 릴리즈 주기가 짧고 서비스를 지속적으로 테스트하고 배포하는 조직의 경우는 git-flow보다 간단한 github-flow 모델을 사용할 수 있다.<br>
<br>
github-flow는 git-flow가 Github에서 사용하기에는 복잡하다고 나온 브랜치 모델이다. 이 브랜치 모델은 메인 브랜치(일반적으로 master 또는 main 브랜치를 의미)에 대한 역할만 잘 관리하는 방식으로 hotfix 브랜치나 feature 브랜치를 구분하지 않고, 새로운 기능 추가 또는 이슈 해결이 필요한 시점에 작업 브랜치를 생성하여 관리하고 작업이 끝난 소스 코드의 병합은 깃허브에서 제공하는 pull request 기능을 사용하도록 권장하는 방식이다.<sup id="part2_2_04">[5](#footnote1)</sup>

<br>

<p align="center"><img src="/assets/part2/image12.png" alt="그림 12. github-flow" title="그림 12. github-flow"></p>

<br>


### :mortar_board: github-flow 사용법
1. **main 브랜치는 어느 시점이든 소프트웨어의 배포가 가능해야 한다.**
    -  먼저 과제 수행 컨소시엄 구성원들에게 분산되어 보관되는 소스 코드가 있는 경우, 모든 소스 코드를 main 브랜치에서 관리하도록 구성한다.
    - main 브랜치는 항상 최신 상태며, 안정적인 상태로 유지되어야 하며 소프트웨어 배포에 사용되는 브랜치. 따라서 이 브랜치에 대해서는 소스 코드를 병합하기 전에 충분한 테스트가 필요하며 엄격한 규칙으로 관리되어야 한다.
    - 테스트는 브랜치를 최신으로 병합하고 릴리즈 관리 도구(Jenkins, Travis CI 등)를 통해 테스트할 수 있도록
구성한다.
2. **기능 추가나 이슈 해결을 위해 소스 코드의 수정을 할 때 브랜치의 생성은 항상 main 브랜치에서 만들고, main 브랜치에서 새로운 일을 시작하기 위해 브랜치를 만들 때는 브랜치의 이름을 명확히 작성한다.**
    - 새로운 기능을 추가하거나, 버그를 해결하기 위한 브랜치 이름은 자세하게 어떤 일을 하고 있는지에 대해서
작성한다.
    - 커밋 메시지는 여러 사람과 같이 개발할 때 서로 간의 코드 리뷰에 도움이 되므로 표준을 정의하고 준수한다.
3. **개발자는 작업 중인 원격 저장소 브랜치로 자주 병합해야 한다.**
    - 항상 원격 저장소에 자신이 하는 작업을 반영하여 다른 사람들도 확인할 수 있도록 해야 한다.
    - 개발환경에 문제가 발생해 작업하던 부분이 없어지더라도, 원격 저장소에 있는 소스를 받아서 작업할 수
있도록 관리해야 한다.
4. **피드백이나 도움이 필요할 때, 그리고 병합할 준비가 완료되었을 때는 풀리퀘스트(pull request)를 생성한다.**
    - 풀리퀘스트(pull request)는 소프트웨어의 형상 관리를 책임지는 책임자에게 소스 코드의 병합을 위해 리뷰를 요청하는 행동이다.
    - 풀리퀘스트(pull request)를 이용해 자신의 코드를 공유하고 리뷰를 요청한 후 리뷰어의 검토 사항에 따라 발견한 리뷰 내용을 수정한다.
    - 리뷰어의 검토사항을 모두 수정하고 병합을 할 준비가 완료되었다면 main 브랜치로 반영을 요구하도록 한다.
5. **소스 코드의 기능에 대한 리뷰가 끝난 후 main 브랜치로 병합한다.**
    - 병합을 반영하면 바로 릴리즈로 반영이 될 기능이므로, 이해관계자들과 충분한 논의 이후 반영하도록 한다.
    - main 브랜치에 병합이 완료되면 작업한 브랜치는 삭제한다.
6. **소스 코드가 main 브랜치로 병합되어 적용되면 소프트웨어의 새 릴리즈가 즉시 배포된다.**
    - 이 부분이 GitHub-flow의 핵심으로 워크플로우 자동화도구인 깃헙액션 또는 자신이 사용중인 릴리즈 관리 도구의 트리거를 이용하여 main 브랜치의 변경이 일어나면 자동으로 배포가 되도록 설정해 놓는다
    - 병합한 이후에는 릴리즈 자동화 도구의 결과를 확인하여 오류가 없는지 점검한다. 

<br>

- 커밋 메시지 작성하기

    공개된 프로젝트에 참여하고 싶은 외부 기여자는 커밋 메시지를 통해 공개된 소프트웨어의 변경 이력을 분석할 때 도움이 되기 때문에 누구나 쉽게 이해할 수 있도록 작성하는 것이 필요하다.<br>
<br>
공개SW 연구개발 과제의 수행자는 소프트웨어 소스 코드 저장소에 새로운 소스 코드가 반영될 때 입력하는 커밋 메시지의 표준을 정의하고 참여연구원 전원이 준수할 수 있도록 관리하여 소프트웨어 소스 코드의 무의미한 커밋을 방지하고 외부 기여자의 쉬운 프로젝트 참여 환경을 구축할 수 있다.<br>
<br>
별도의 커밋 메시지 표준이 없는 경우에는 다음과 같은 커밋 메시지 규칙(Udacity Git Commit Message Style
Guide)을 참고할 수 있다. <sup id="part2_2_06">[6](#footnote3)</sup>

<br>

- 커밋 메시지는 크게 제목, 본문, 꼬리말 세 가지 부분으로 나누고, 각 부분은 빈 줄을 두어 구분하여 작성하자. 
- type : 어떤 의도로 커밋을 했는지 알 수 있도록 type에 명시.
- subject : 최대 50글자가 넘지 않도록 하고 마침표는 찍지 않는다. 영문으로 표기하는 경우 동사(원형)를 가장 앞에 두고 첫 글자는 대문자로 표기.
- body : 긴 설명이 필요한 경우에 작성. 어떻게 했는지가 아니라, 무엇을 왜 했는지를 최대 75자를 이내로 작성.
- footer : issue tracker ID를 명시하고 싶은 경우에 작성.

<br>

<p align="center"><img src="/assets/part2/image13.png" alt="그림 13. 커밋 메시지 구조" title="그림 13. 커밋 메시지 구조"></p>

<br>

이런 규칙을 적용하여 커밋 메시지를 작성하면 다음과 같이 작성할 수 있다.<br>

<p align="center"><img src="/assets/part2/image14.png" alt="그림 14. 커밋 메시지 작성 예" title="그림 14. 커밋 메시지 작성 예"></p>
---

<b id="footnote1">4</b>) https://github.com/todogroup/ospo101 <sup>[return](#part2_2_04)</sup><br>
<b id="footnote2">5</b>) https://hellowoori.tistory.com/56 <sup>[return](#part2_2_05)</sup><br>
<b id="footnote3">6</b>) https://udacity.github.io/git-styleguide/ <sup>[return](#part2_2_06)</sup><br>